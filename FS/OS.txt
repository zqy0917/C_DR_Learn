
第一章  引论

1: 操作系统的功能？
处理机管理（进程控制，进程同步，进程调度，进程通信），存储管理（内存分配，存储保护，内存扩充），设备管理（缓冲管理，设备分配，设备处理，虚拟设备），文件管理（文件存储系统的管理，目录管理，文件的读写管理以及文档的共享与保护）
用户接口：它是提供给用户使用的接口，用户可通过该接口取得操作系统的服务
程序接口：它是提供给程序员在编程时使用的接口，是用户程序取得操作系统服务的唯一途径。
实现了对计算机资源的抽象，隐藏了对硬件操作的细节。

2: OS 设计的目标
答：方便性(使计算机系统易于使用)、有效性(提高计算机的资源利用率)、可扩充性(方便的增加新的模块)、开放性(遵循世界标准规范)。

3: OS 具有哪几大特征？之间有何关系？
答：并发性、资源共享性、虚拟性、异步性。
并发性和资源共享性是最基本的特征。为了提高计算机资源利用率，OS 必然要采用多道程序设计技术，使多个程序共享资源，并发地执行。虚拟性以并发和资源共享为前提，在逻辑上增加CPU和设备数量以及存储器容量。异步性是并发和资源共享的必然结果。

4: Windows 属于单用户多任务操作系统，该系统只允许一个用户登录，但允许用户把程序分成若干个任务，使它们并发运行。Unix/Linux 属于多用户多任务操作系统。

5: 什么是分时操作系统什么是实时操作系统？
分时系统：
分时操作系统是一个联机的多用户交互式的操作系统。我们把一台计算机连接多个终端的计算机系统称为分时计算机系统。
分时技术：把处理机的响应时间分成若干个大小相等或不等的时间单位，称为时间片（如100毫秒），每个终端获得CPU，就等于获得一个时间片，该用户程序开始运行，当时间片用完，用户程序暂停运行，等待下一次运行。
特点：
  （1）人机交互性好：在调试或运行程序时由用户自己操作。
  （2）共享主机：多个用户同时使用。
  （3）用户独立性：对每个用户好像独占主机。
和多道批处理系统相比具有非常明显的不同特性：
  （1）多路性：允许多个用户共享一台计算机，显著提高了资源利用率，降低了使用费用
  （2）独立性：每个用户在各自的终端进行操作，彼此之间互不干扰，感觉像一人独占主机操作
  （3）及时性：指用户请求在很短时间内就可获得响应。通常1~3秒
  （4）交互性：用户可通过终端与系统进行广泛的人机对话，其广泛性表现为用户请求多方面的服务
实时系统
实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致的运行。
特点：有限等待时间，有限响应时间，用户控制，可靠性高，系统出错处理能力强
实时系统与分时系统的比较：
  （1）多路性：信息查询系统和分时系统的多路性都表现为系统按分时原则为多个终端用户服务；实时控制系统的多路性则是指系统周期性地对多路现场信息进行采集。
  （2）独立性：彼此之间也是互不干扰的。
  （3）及时性：信息查询系统和分时系统是依据人所能接受的等待时间确定的，实时控制系统的实时性则是以控制对象所要求的截止时间来确定的。
  （4）交互性：信息查询系统中，人与系统的交互性仅限于访问系统中某些特定的专用服务程序，不像分时系统能向终端提供数据处理、资源共享等服务。
  （5）可靠性：分时系统要求系统可靠，实时系统要求系统更可靠。

5: 什么是中断？
答：中断是指CPU在收到外部中断后停止原来的工作，转去处理该中断事件，完毕后回到原来断点继续工作。中断处理过程：中断请求，中断响应，中断点（暂停当前任务并保存现场）

6: 并发、并行、同步、异步的区别？
并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。并行依赖于多核 CPU 或者多 CPU 的系统。
并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。
同步通俗讲是指，两个任务的开始执行时间，执行结束时间，都有着严格的规定，并且按照这个规定执行。
而异步则指，两个任务何时开始执行，以何种速度推进，何时结束都是互相独立，互不干扰的。


第二章  进程管理(重点)
1: 什么是进程？
答：进程是程序在一个数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位，由程序段、相关的数据段、PCB(Process control block)组成，其中PCB是核心。
在进程的整个生命周期中，系统总是通过其PCB对进程进行控制，系统是根据进程的 PCB 而不是任何别的什么而感知进程存在的，所以说，PCB 是进程存在的唯一标志。
PCB 中主要包括以下四个方面的信息：
1.进程标志符  2.处理机状态   3.进程调度信息   4.进程控制信息
进程的特征：
（1）动态性：它由创建而产生，由调度而执行，由撤消而消亡
（2）并发性：指多个进程同时存在于实体内，并且能在一段时间内同时运行
（3）独立性：指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。
（4）异步性：进程是按异步方式运行的，按各自独立的，不可预知的速度向前推进。

2: 进程有哪些状态？
答：创建状态、就绪状态、执行状态、阻塞状态、挂起状态、终止状态。
（1）引起创建进程的事件：用户登录，作业调度，提供服务，应用请求
（2）引起进程终止的事件：正常结束，异常结束，外界干预
（3）引起进程阻塞和唤醒的事件：1.请求系统服务 2.启动某些操作 3.新数据尚未到达 4.无新工作可做。若发生了上述某事件，进程便通过调用阻塞原语block将自己阻塞，当被阻塞进程所期待的事件发生后，则有关进程调用唤醒原语wakeup,将等待该事件的进程唤醒
进程的挂起：当系统中引起进程挂起的事件时。OS将利用挂起原语suspend将指定进程或处于阻塞状态的进程挂起
进程的激活过程：当系统中发生激活进程的事件时，OS将利用激活原语active，将指定进程激活。

3: 多个进程访问临界资源等同步问题
采用信号量机制可以解决，信号量分为：
(1)整形信号量，在 wait 操作中只要 S<=0 就会不断地测试，不遵循让权等待原则。
(2)记录型信号量，存在一个进程链表指针代表一个等待的进程队列，每当调用 signal 时，如果 S.value 加一后仍然小于等于0，则将链表中的第一个进程 wekeup
(3)AND 型信号量，解决多进程竞争多资源问题，要么将全部资源分配给进程，要么一个也不分配。
注：同步机制应遵循的规则：空闲让进，忙则等待，有限等待，让权等待

4: 使用信号量机制实现前驱关系
例：两并发进程 p1(有语句S1)，p2（有语句S2），我们希望 S1执行完后执行S2。则可以初始化一个初值为0的信号量 S，在 S1后面执行 Signal(S), 在 S2 前面执行 Wait(S),这样即可保证先执行到 S2 时被动等待。

5: 进程同步中的经典例子：生产者－消费者问题、哲学家进餐问题(使用 AND 型信号量最合适，当哲学家满足左右手都有筷子时才允许访问资源)、读者－写者问题。

6: 进程间的高级通信机制三类：共享存储器系统(生产者－消费者)、消息传递系统(分为直接和间接)、管道通信系统
共享存储器系统：相互通信的进程共享某些数据结构或公共存储区来进行通信，需要处理同步问题。
消息传递系统：进程间通过 OS 提供的通信原语直接进行通信。send，receive 原语
管道通信方式：指用于连接一个读进程和一个写进程以实现通信的一个共享文件。

7: 消息缓冲队列通信机制
PCB中存放一个消息队列首尾指针和消息队列互斥信号量。是使用 send 和 receive 系统调用时的数据结构。
发送过程为：1，发送端将消息、长度、发送进程标识符等信息填入自己的发送区a；2，将a中的信息复制到申请的缓冲区i中，并获取接受进程的队列指针，将i挂在队列上。(消息队列属于临界资源，需要使用消息队列互斥信号量)
接收过程为：接收进程从自己的消息队列中取出第一个消息缓冲区i，并将i中的数据复制到以b为首地址的消息接收区内。

8: 什么是线程？
答：由于进程在创建、撤销、切换时的开销较大，而线程的引入则可以更好的提高系统的并发程度。
在一个进程中包含多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体，是独立调度和分派的基本单位。
在引入多线程的系统中，线程是 CPU 调度的实体，而进程是资源拥有者。

9: 在多线程OS中，进程仍然是系统分配资源的基本单位，但不作为一个可执行的实体，而是把线程做为独立运行的基本单位。进程被挂起，内部所有线程被挂起，反之全部被唤醒。
线程非常轻量，一般情况下线程只拥有一些必不可少的资源。例如：一个程序计数器、TCB、保存局部变量的一组堆栈和寄存器。

10: 线程的同步机制可以使用互斥锁或者信号量机制。

11: 线程类型有3种：内核支持线程、用户级线程、前两者组合方式
(1)内核支持线程，在内核中存在线程控制块，是内核感知存在的，并对其控制。
优点：1，当进程中的一个线程阻塞时，内核可以调度该进程的其他线程；2，内核支持线程比较轻量，切换速度快。
缺点：对于用户线程切换而言，模式切换开销较大。需要从用户态切换到内核态。
(2)用户级线程，在用户空间中，内核对其无感知。
优点：1，切换发生在进程内部，无需内核的支持，切换速度很快，并且节省了模式切换开销；2，可以拥有自身的调度算法。
缺点：内核每次只会给进程分配一个CPU，并且在一个时间片之内，在将时间分给每个用户级线程。(进程内的用户级线程越多，每个线程分配到的CPU时间越少)
(3)组合方式，结合前两者优点，克服了不足，最优选择。

12：三种线程的实现
(1)内核支持线程，系统在创建进程时自动分配若干TCB(Thread control block)空间, 进程创建线程时分配TCB和必要资源(栈和局部存储区)，同进程采取一样的时间片轮换算法，优先权算法等。也分为抢占式和非抢占式。
(2)用户级线程，1，采用运行时系统，管理进程内线程创建、销毁、通信、调度等的函数集合，有它才使用户级线程与内核无关。相当于进程内用户级线程的总管家。当需要获得系统资源时，用户级线程无法直接进行系统调用，所以也是通过运行时系统来进行系统调用；
2，轻进程LWP(Light Weight Process)。LWP可以共享进程资源和系统调用，所以只要将用户级线程连接到LWP上就有了内核支持线程的所有属性，这也是组合方式。通常将若干个LWP做成线程池，用户级线程与LWP采取 “一对一”、“一对多”和”多对多“的方式相连。

13: pthread 创建的 PTHREAD_SCOPE_PROCESS 线程属于用户级线程，默认情况下，对于一个拥有n个线程的进程，启动多少 LWP，由哪些 LWP 来控制哪些线程由操作系统来控制，这种状态被称为非绑定的。那么绑定的含义: 只要指定了某个线程“绑”在某个 LWP 上，就可以称之为绑定的了。总之pthread创建的 PTHREAD_SCOPE_PROCESS 线程需要依赖绑定 LWP 获取 CPU 调度。
当创建的线程 CPU 时间设置为 PTHREAD_SCOPE_SYSTEM 时，代表这个线程跟该内核的所有线程抢夺调度机会，那么它就是内核线程，在 Linux 系统中也叫 LWP 轻进程。
注：上述理解均在Linux环境下

14: 线程通信和进程通信
一，进程通信有以下几种方式：
（1）无名管道(pipe)及有名管道(FIFO)：
无名管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。其内部的数据同步机制由内核负责维护。
相关 API：pipe，mkfifo，read，write
（2）消息队列(message queue)：
消息队列，是消息的链表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。具有写权限得进程可以按照一定的规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。其内部的数据同步机制由内核负责维护。
相关 API：msgget，msgsnd，msgrcv（分成阻塞和非阻塞方式）
（3）共享内存(shared memory)：
相对常用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要自行实现某种同步操作，如互斥锁和信号量等。共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
相关 API：shmget，shmat，shmdt 等
（4）信号量(semaphore)：
主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。
相关 API：semget，semop，semctrl 等
（5）套接字(socket)；
可用于网络中不同机器之间的进程间通信，应用非常广泛。
相关 API：send，receive，connect，select 等
二，线程间的内存本身就是共享的所以进行通信方式比较简单，注意资源的同步
（1）信号量的方式进行线程同步：既可以实现资源互斥，也可以实现线程同步（一方wait，另一方 signal）。
（2）加锁的方式实现资源同步：互斥锁、递归锁、自旋锁、读写锁等。
（3）条件变量：pthread_cond。等待分成有条件等待和无条件等待（加个时间限制），都会释放处理机资源。无论哪种等待方式，都必须和一个互斥锁配合，以防止多个线程同时请求。激活操作也分两种：激活一个等待该条件的线程（存在多个等待线程时按入队顺序激活其中一个）；激活所有等待线程
（4）事件的方式，例如 iOS 中的 performSelectorOnThread 将这次执行放入对应线程的 RunLoop 事件源中，等待本次 RunLoop 运行结束执行。所以如果是子线程且没开启 RunLoop 调用该方法无效。

15: 僵尸进程、孤儿进程、僵尸线程
任何一个子进程在 exit 之后会进入终止(僵尸)状态，进入这个状态后进程不在被调度，但在操作系统中依然保留着一个记录，其中包含状态码和一些计时统计数据，供其他进程收集，一旦其他进程收集完毕后，操作系统将删除该进程。
（1）孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程所收养，并由init进程对它们完成状态收集工作。
（2）僵尸进程：如果子进程在 exit() 之后，父进程没有来得及处理，则会导致这个 pid 仍然被占用。如果数量过多则会占用大量进程资源。正确的做法是需要父进程及时的调用 wait() 或者 waitpid() 收集子进程将其释放。
当这个父进程被 kill 掉时，这些僵尸进程将变成孤儿进程由 init 进程接管释放。
（3）僵尸线程：概念类似于僵尸进程，线程在创建时可以指定其 JOINABLE 或者 DETACH 状态（也可以在线程创建并运行以后用pthread_detach()来设置），设置成 JOINABLE 状态的线程需要我们主动的收集线程状态从而回收，类似于僵尸进程。而设置成 DETACH 状态的线程则由系统进行回收。
pthread_join()函数，以阻塞的方式等待thread指定的线程结束。当函数返回时，被等待线程的资源被收回。如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。


第三章  处理机调度与死锁(重点)
1: 处理机三种调度：高级调度(作业调度)、低级调度(进程调度)、中级调度(将具备运行条件的、在外存上的挂起进程，重新调入内存)

2: 作业是什么？
答：包含程序、数据、作业说明书的用户提交任务。核心是JCB(Job control block),同 PCB 一样包含了作业的全部信息。进入系统的作业会被建立一个JCB，插入到后备队列中。

3: 作业和进程区别与联系？
答：一个作业通常包括几个进程，几个进程共同完成一个任务，即作业。
用户提交作业以后，当作业被调度，系统会为作业创建进程，一个进程无法完成时，系统会为这个进程创建子进程。
区别：进程是一个程序在一个数据集上的一次执行；而作业是用户提交给系统的一个任务，例如终端命令

4: 进程调度功能？
答：1，保存进程上下文(寄存器、程序计数器内容等)到PCB；2，按某种算法选取进程；3，为选中进程恢复上下文。

5: 进程调度三个基本机制：排队器(将就绪进程按一定方式排成多个队列)；分派器(取出进程，切换上下文，分配处理机)；上下文切换机制(保存当前进程上下文，切换到分派进程的上下文)

6: 进程调度方式有哪些？
答：抢占方式和非抢占方式。其中抢占方式遵循优先权原则、短作业优先原则、时间片原则。

7: 调度队列的三种模型
答：1，仅有进程调度的模型，通常将就绪队列组织成FIFO队列；对于命令，则由 OS 为之创建一个进程，并加入到就绪队列。
2，具有高级和低级调度的队列模型，高级调度将作业调入内存并分配进程，准备就绪后由低级调度将进程调入就绪队列，准备分时执行；
3，包含高中低三级调度的模型，其中中级调度负责挂起进程的外存调入内存、内存调入外存任务。

8: 调度算法分类：先来先服务(利用FIFO队列实现，有利于长作业)、短进程优先(优先选择估计运行时间最短的作业或进程，有利于短作业)、优先权调度算法(细分为抢占式、非抢占式)、高响应比优先算法(折衷的方式，既有利于短作业，又防止长作业等待过久，核心算法是优先权对着等待时间的增加而动态的增加)

9: 优先权类型：静态优先权(创建进程时确定，在进程整个运行期间保持不变)、动态优先权(优先级会随着进程的推进或等待时间增长而增加)

10: 基于时间片的轮转调度算法。时间片轮转法和多级反馈队列调度算法(后者认可度比较高)
时间片轮转法，CPU在就绪队列中依次执行一个时间片，每个进程执行完一个时间片后如果结束则退出队列，反之加入到就绪队列末尾。时间片大小需适中。
多级反馈队列调度算法，设置多个就绪队列，优先级越来越低，时间片越来越长，每个新任务从最高优先级队列开始执行，执行不完放入下一个队列尾。仅当前面的队列空闲时，才执行当前队列，如果执行中有新进程进入队列，则被抢占。该算法兼顾短任务，终端任务和长任务。

11: 实时调度需具备的条件：1，提供必要的信息(就绪时间、开始截止时间和完成截止时间、处理时间、资源要求、优先级)；2，处理系统能力强；3，采用抢占式调度机制；4，具有快速切换机制

12: 实时调度算法分类。1，非抢占式调度算法，又可细分为非抢占式轮转调度算法和非抢占式优先调度算法、抢占式调度算法(细分为基于时钟中断的抢占式优先权调度算法和立即抢占的优先权调度算法)
非抢占式轮转：将任务排成轮转队列，每次获取队首并分配CPU执行，执行完挂在队尾。用于要求不太严格的实时控制系统。
非抢占式优先：如果任务中存在要求较为严格的任务，则赋予较高的优先级并且挂在队首。
基于时钟中断的抢占式优先权调度算法：某个高优先级实时任务到达后，并不立即抢占处理机，而是等待时钟中断的到来，调度程序才将处理机分配给它。
立即抢占的优先权调度算法：一旦出现外部中断，立即剥夺当前任务，分配处理机。

13: 两种实时调度算法：1，最早截止时间优先即 EDF(earliest deadline first), 也分为抢占式和非抢占式。其中抢占式调度方式依据最早截止时间来抢占，只有新任务的最早截止时间比当前任务早才抢占处理机。
2，最低松弛度优先即LLF算法。即根据松弛度确定优先级。松弛度 ＝ 截止时间－本身剩余运行时间－当前时间

14: 产生死锁的原因有哪些？
答：1，竞争临界资源引起死锁，如 P1 占用 R1, P2 占用 R2，而 P1 继续执行需要等待 R2，P2 继续执行需要等待 R1，故引起死锁。2，进程推进顺序不当引起死锁。

15: 产生死锁的必要条件：1，资源互斥，同一时刻只能被一个进程占用；2，请求和保持同步，即一个进程已经占有了一个资源，但是继续请求另外的正在被占用的资源；3，不剥夺条件，即已被占用的资源不可被剥夺；4，形成环路等待。

16: 处理死锁基本方法：1，预防死锁；2，避免死锁；3，检测死锁；4，解除死锁

17: 怎样预防死锁？
答：1，摒弃请求与保持条件，即只要有一种资源无法满足分配要求，则其他资源也不分配给该进程。该方法实现简单，但易造成资源浪费；2，摒弃不剥夺条件，即如果某个进程提出新资源请求而不能立即满足时，必须释放已经保持的资源。该方法实现起来有些困难；3，摒弃环路等待，即所有的资源进行线性排队并赋予序号，进程申请资源时必须按序号递增。该方法对用户限制比较大。

18: 系统安全状态检测避免死锁。每次分配资源之前进行安全性检测，决定系统状态是否安全。所谓安全状态，即是否存在一个进程顺序，可以利用剩余资源依次顺利完成。

19: 银行家算法步骤：
(1)检测请求资源数量是否小于可用数量，是否小于当前进程所需要数量，是则跳转到(2)，否则等待
(2)试探着将资源分配给进程，并作系统安全性检查，安全则分配，否则等待。
系统安全状态检测，即是否可以找到一个进程序列，使得当前可用资源按照该序列分配，可以顺利执行完每一个进程。存在既安全。

20: 死锁的检测：方法类似于银行家算法的系统安全状态检测，如果最后是安全状态则没发生死锁，否则死锁。

21: 死锁的解除：1，剥夺资源，从其他进程剥夺足够的资源给死锁进程，解除死锁；2，撤销进程


第四章  存储器管理
1: 多级存储结构：1，CPU寄存器(速度最快。最昂贵)；2，主存也叫内存(细分为：高速缓存、主存、磁盘缓存)；3，辅存(磁盘，可移动存储介质)。

2: 程序装入方式：1，绝对装入方式(逻辑地址和实际地址相同)；2，可重定位装入方式(编译时通常以0地址开始为相对地址，实际地址则存在一定的偏移量)；3，动态运行时装入方式(将绝对地址的分配延迟到程序运行时，可以适应程序位置的移动)

3: 程序的链接方式：1，静态链接方式,既将目标模块的相对地址修改，使之连成一个模块，通常不在拆开，运行时可直接装入内存；2，装入时动态链接，在装入内存时发现有其他模块的调用，则按照1的方式修改目标模块的相对地址。边装入边链接；3，运行时动态链接，该方法是对上述的改进，在运行时发现外部模块调用时，立即由OS查找该模块并将之装入内存，连接到调用者模块上。既加快程序的装入，也节省了大量的内存。

4: 四种内存的连续分配方式：1、单一连续分配；2，固定分区分配；3，动态分区分配；4，动态重定位分配

5: (1)单一分配方式只能用于单用户、单任务的OS中；
(2)固定分区分配，既将内存划分成若干大小相同(或者不同)的区域，并将各个分区进行排队，由内存分配程序分配。
(3)动态分区分配，指根据进程的实际需要，动态的为之分配内存。其描述空闲分区的数据结构是空闲分区表或空闲分区链；按照一定的分区分配算法为进程分配空间。(首次适应算法、循环首次适应算法、最佳(坏)适应算法、快速适应算法)，其中快速适应算法，将空闲分区根据容量大小分类并且是设置多个空闲分区链表。需要分配多大空间，只需去对应的链表头寻找空闲分区即可，空间换时间。
注意：初始时，空闲分区为一个整体，随着内存的分配和回收，才会产生若干个不连续的空闲分区，此时空闲分区链表个数大于1。
(4)可重定位分区分配类似于动态分区分配，当找不到足够大的分区时，通过移动相关已分配的分区(修改重定位寄存器的地址)，进行分区紧凑，腾出足够的分区。

6: 对换 细分为：整体对换(进程对换)和部分对换(分页／分段)。
在进程对换中，由于某些进程需要创建子进程没有多余空间或者发生阻塞时，系统应该将该进程的程序和数据传送到磁盘的对换区上，并回收该进程，并对该进程的PCB做相应的修改。
系统定时查看所有进程的状态，找出就绪状态但已唤出的进程，将其中唤出时间最久的进程调入内存中。

7: 重定位分区分配的“紧凑”方式虽然可以将碎片空间拼接成大块，但是需要为之付出很大代价(移动其他进程、修改重定位寄存器等)。如果允许一个进程直接分散地装入到许多不相邻的分区中，则无需紧凑，由此诞生分页存储和分段存储管理方式。

8: 基本分页存储方式：将进程逻辑地址空间和系统内存空间划分成大小相同的页和内存块，并加以编号(从0开始),分页地址结构由页号和位移量(也称为页内地址)组成，为了保证程序正确运行，还需要为每个进程建立一个页面映射表(简称页表即页号映射到物理地址)。

9: 基本的页表的功能由一组专门的寄存器来实现，进程未执行时，页表首地址和长度存储在PCB中，当调度程序调度该进程时，将页表数据装入到页表寄存器中。当进程要访问某个逻辑地址中的数据时先查询页表的到物理地址后在访问数据。

10: 由于基本的页表需要访问两次内存，太过耗时，所以为了提高效率，在地址变换机构中增设了一个具有并行查询能力的"联想"(“快表”)，每次使用页号 P 访问页表之前先查询快表，查询到则直接区数据，否则查询页表，并将本次查询缓存到快表中，当快表满时，替换掉旧的不再使用的缓存数据。

11: 二级页表和多级页表，是为了解决页表占用过大内存空间的问题，建立页表的页表的页表....

12: 分段存储基本原理：分段系统中，作业地址划分为若干个段，每个段定义了一组逻辑信息，例如：主程序段MAIN，子程序段FUNC等。分段地址由段号和段内地址构成。和分页存储一样，分段存储也需要一个段号－物理地址映射表(段表), 地址变换机构为段表寄存器，同分页系统一样也需要访问两次内存，也可以使用联想存储器进行优化。

13: 分页和分段存储的区别？
答：1，分页是信息的物理单位，仅仅是系统为了提高内存利用率的需要，而分段则含有一组意义相对完整的信息，分段目的为了更好的满足用户的需要；2，分页的大小由系统固定，而分段的大小取决于程序，在编译时根据信息的性质来划分；

14: 分段存储的一个突出优点是易于实现信息共享。分页存储多个进程进行信息共享时，需要在PCB中的页表中存入多个块号(指向的程序物理地址可能还是重复的)，而分块存储系统中只需在每个进程中设置一个段表项即可。

15: 段页式存储方式
分页存储可以有效的利用内存，分段存储可以更好的满足用户需要，为了结合二者的优点，产生了段页式存储方式。 其地址结构由段号（S），段内页号（p），页内地址（W）组成。
该方式地址变换过程为：首先使用段号S 和 段表长度 TL 比较看是否越界。
然后根据段号S 和段表始址找到该段对应的段表项，获取到表中的页表大小和页表始址两项。
然后根据地址结构中的段内页号 P 和页表始址获取到对应的页表项从而找到对应的物理块号 b，最后利用地址结构中的页内地址 w 和 b 获取到最终的物理地址。

16: 虚拟存储器的定义？
答：利用程序执行的局部性原理，将程序按照需要分批的装入到内存中运行，而不是像常规存储器一样，一次性将程序和数据全部装入内存后再运行。如果程序执行时需要访问的页／段尚未装入内存，则利用 OS 提供的请求调页(段)功能。如果此时内存已满，则需要利用系统的页(段)置换功能。
定义：虚拟存储器是指具有请求调入和置换功能，能从逻辑上对内存加以扩充的系统。

17: 虚拟存储器由分页请求系统和分段请求系统两种。虚拟存储器具有多次性(一个作业会被分成多次调入内存运行)、对换性(作业的运行过程中会发生多次换进，换出)、虚拟性(是从逻辑上扩充内存容量，是用户看到的内存容量远大于实际，这是虚拟存储器最重要的目标)

18: 请求分页中需要哪些硬件支持？
答：1，页表机制(用来存放程序／数据页的页号、状态、外存地址等信息)；2，缺页中断机构(当程序需要读取的数据不在内存时，需要该机构中断进程，进行调页)；3，地址变换机构(在分页地址变换机构的基础上，添加了内外存置换，以及查询快表的功能)。

19: 物理块分配策略有哪三种？
答：1，固定分配局部置换，该方法每个进程分配的物理块数确定，并且只能在进程内部做页面置换。2，可变分配全局置换，该方法OS自身维护一个空闲物理块队列，某进程缺页时会分配。3，可变分配局部置换，缺页置换还是在进程内部实现，但是系统会给频繁缺页的进程增加分配物理块，反之缺页率很低的进程系统会回收部分物理块。

20: 物理块分配算法有哪些？
答：1，平均分配(总块数／进程数)；2，按比例分配(进程页数多的分配得多)；3，考虑优先权分配(一部分按比例分配，一部分按进程优先权分配)

21: 页面调入的过程分为几步？
答：1，CPU收到页面中断信号；2，中断程序保留CPU环境，并查找页表的到该页的物理地址，此时如果内存能够容纳则启动磁盘 IO，将新页换入内存；3，如果内存已满，则需要按照某种算法选择一页换出，换出页如果没有修改过则不需写回磁盘，反之需要。然后把新页面调入内存，并修改页表和快表。利用新的页表寻找物理地址。

22: 什么是页面置换算法？都有哪几种页面置换算法？
答：当发生页面缺失并且内存空间已经满时，则需要使用适当算法选择一个页面换出内存，该算法称为页面置换算法。
1，最佳置换算法(理想状态，现实中不存在，仅作为优秀的置换算法的参考)。即每次换出的页面都是永久不使用或者未来最久未被使用的。
2，先进先出(FIFO)置换算法，将页面排成FIFO队列，每次取队首换出，该方法效率较差，几乎未被使用。
3，LRU(Least Recently used) 最近最少使用置换算法，该算法并没有达到最佳置换算法那样可以预测“未来”，而是着眼于现在每个分页的使用情况，当出现内存满时，选择当前内存中一个最久未使用的分页换出。可以采用一个栈结构来实现该算法，每次将需要使用的页面放在栈顶，当栈满时栈底页面一定是最久未被使用的，换出即可。
4，CLOCK 置换算法，将所有页链接成一个循环队列，给每个页设置一个访问位，被访问时，访问位置1。选择一页淘汰时，只需按顺序访问链表直到访问位位0则替换，若访问位为1则重置为0，暂时不换出。检查完最后一个还没找到0时，则从头再来，过程循环类似于 CLOCK。

23: 请求分段存储管理方式中的硬件支持：1，段表机制；2，缺段中断机构；3，地址变换机构

第五章  设备管理
1: 什么是设备控制器？它有何作用？
答：设备控制器是计算机中的一个实体，其主要职责是控制一个或多个IO设备，以实现IO设备和计算机之间的数据交换。它是CPU与IO设备之间的接口，它接收从CPU发来的命令，并去控制IO设备，以使处理机从繁重的设备控制事务中解放。

2: 设备控制器的基本功能有哪些？
答：1，接收并识别 CPU 命令；2，数据交换；3，识别和报告设备的状态，例：仅当设备处于就绪状态时CPU才可以启动设备控制器读数据；4，地址识别，需要识别 CPU 寄存器地址和硬件地址；5，数据缓冲，CPU 读写速率比硬件快很多需要缓冲区适配；6，差错控制。

3: 当主机外围设备很多时 CPU 仍需耗费很多资源去处理，由此引入 IO 通道。
CPU 只需要将指令传给 IO 通道，IO 通道执行完相关操作后，才向 CPU 发送中断信号。由此很大程度上节省了 CPU 资源。
目前大多采用数组多路通道，该通道可以并行的控制多个设备控制器。
IO 通道是一种特殊的处理机，它具有执行 IO 指令的能力。现广泛使用 “数组多路通道” 类型的 IO 通道，即可以分时的处理各个设备之间的一块数据。

4: 总线系统的作用？
答：CPU、存储器以及各种IO设备之间的联系都是通过总线来实现的。例：CPU 向存储器中读取进程数据，向IO设备中读取数据等都会通过总线来传输，因此总线的传输速率、带宽、时钟频率等的要求不断在提高。

5: 程序 I/O 控制方式和中断驱动 I/O 控制方式的区别？
答：程序 I/O 控制方式会使 CPU 一直等待 IO 控制器执行结束，再做相关处理。而中断驱动 IO 控制方式中，CPU 将执行指令通知 IO 控制器后继续做其它事，而 IO 控制器执行完后会主动向 CPU 发送中断信号通知 CPU，CPU回来做差错检测读写内存等操作。程序 IO 方式浪费 CPU资源，而中断驱动方式则可以很好的利用 CPU。

6: 虽然中断驱动方式很有效，但是该方式是以字节为单位，意味着如果有100字节的数据要处理会对CPU做100次中断。DMA 控制方式解决了这个问题，DMA 控制器内部有数据寄存器和数据计数器，仅当数据计时器为0时（已传输完毕），才会对 CPU 进行中断操作。大大减少了对 CPU 的干预。

7: 设备管理中引入缓冲区的目的？
答：（1）缓和 CPU 与 IO 设备间速度不匹配的矛盾。（2）减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制。（3）提高 CPU 和 IO 设备之间的并行性。

8: 三种缓冲机制单缓冲、双缓冲、循环缓冲各自特征？
答：（1）单缓冲即只分配一个缓冲区，此时如果是两台机器 A 和 B 进行通信则只能实现单工通信。（2）双缓冲机制，该机制可以使 A 和 B 双工通信。（3）双缓冲虽然可以实现双工，但是如果两个端的速度不匹配则需要更多的缓冲区组成循环缓冲，循环缓冲需要三个指针，Nexti、Nextg、Current，分别代表输入进程下个可用、计算进程下个可用、计算进程正在使用。

9: 当系统较大时，将会有许多这样的循环缓冲，因此系统一个缓冲池，池中布置了多个可供若干进程共享的缓冲区。
因此需要三个队列：空闲缓冲队列 emq、输入队列 inq、输出队列 outq。由于缓冲池时共享空间，因此需要使用相关的进程同步机制。
收容输入：调用 GetBuf 从空缓冲队列 emq 队首摘下一个空缓冲区作为收容输入 hin，然后把数据输入，装满后调用 putbuf 将 hin 挂到输入队列上等待输入。
提取输入、收容输出、提取输出的步骤类似。

🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥







